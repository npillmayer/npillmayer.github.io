<!DOCTYPE html><html lang="en-gb"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Why GoRGO? - github.io</title><meta name="description" content="Every software developer hates repetitive tasks. What’s the point of being a programmer if you can’t delegate your chores to a machine? And as a backend developer you are&hellip;"><meta name="generator" content="Publii Open-Source CMS for Static Site"><link rel="canonical" href="https://npillmayer.github.io/posts/why-gorgo/"><link rel="alternate" type="application/atom+xml" href="https://npillmayer.github.io/feed.xml" title="github.io - RSS"><link rel="alternate" type="application/json" href="https://npillmayer.github.io/feed.json" title="github.io - JSON"><meta property="og:title" content="Why GoRGO?"><meta property="og:image" content="https://npillmayer.github.io/media/posts/1/GoRGO-Logo-small.png"><meta property="og:image:width" content="616"><meta property="og:image:height" content="460"><meta property="og:site_name" content="github.io"><meta property="og:description" content="Every software developer hates repetitive tasks. What’s the point of being a programmer if you can’t delegate your chores to a machine? And as a backend developer you are&hellip;"><meta property="og:url" content="https://npillmayer.github.io/posts/why-gorgo/"><meta property="og:type" content="article"><link rel="preload" href="https://npillmayer.github.io/assets/dynamic/fonts/aleo/aleo.woff2" as="font" type="font/woff2" crossorigin><link rel="stylesheet" href="https://npillmayer.github.io/assets/css/style.css?v=96b5f3ed26de54ba4369c37700844088"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.27/dist/katex.min.css" integrity="sha384-Pu5+C18nP5dwykLJOhd2U4Xen7rjScHN/qusop27hdd2drI+lL5KvX7YntvT8yew" crossorigin="anonymous"><script defer="defer" src="https://cdn.jsdelivr.net/npm/katex@0.16.27/dist/katex.min.js" integrity="sha384-2B8pfmZZ6JlVoScJm/5hQfNS2TI/6hPqDZInzzPc8oHpN5SgeNOf4LzREO6p5YtZ" crossorigin="anonymous"></script><script defer="defer" src="https://cdn.jsdelivr.net/npm/katex@0.16.27/dist/contrib/auto-render.min.js" integrity="sha384-hCXGrW6PitJEwbkoStFjeJxv+fSOOQKOPbJxSfM6G5sWZjAyWhXiTIIAmQqnlLlh" crossorigin="anonymous" onload="renderMathInElement(document.body);"></script><script type="application/ld+json">{"@context":"http://schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https://npillmayer.github.io/posts/why-gorgo/"},"headline":"Why GoRGO?","datePublished":"2021-01-02T20:28+01:00","dateModified":"2026-01-23T10:44+01:00","image":{"@type":"ImageObject","url":"https://npillmayer.github.io/media/posts/1/GoRGO-Logo-small.png","height":460,"width":616},"description":"Every software developer hates repetitive tasks. What’s the point of being a programmer if you can’t delegate your chores to a machine? And as a backend developer you are&hellip;","author":{"@type":"Person","name":"Norbert Pillmayer","url":"https://npillmayer.github.io/authors/norbert-pillmayer/"},"publisher":{"@type":"Organization","name":"Norbert Pillmayer","logo":{"@type":"ImageObject","url":"https://npillmayer.github.io/media/website/avatar.png","height":256,"width":256}}}</script><noscript><style>img[loading] {
                    opacity: 1;
                }</style></noscript><style>.fi{fill:none;stroke-linecap:round;stroke-linejoin:round;vertical-align:middle}</style></head><body class="post-template"><div class="container"><div class="left-bar"><div class="left-bar__inner"><header class="header"><a class="logo" href="https://npillmayer.github.io/"><img src="https://npillmayer.github.io/media/website/avatar.png" alt="github.io" width="256" height="256"></a><nav class="navbar"><button class="navbar__toggle" aria-label="Menu" aria-haspopup="true" aria-expanded="false"><span class="navbar__toggle__box"><span class="navbar__toggle__inner">Menu</span></span></button><ul class="navbar__menu"><li><a class="tltp" href="https://npillmayer.github.io/" target="_self" aria-label="Home"><svg class="fi fi-home" width="24px" height="24px" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><use href="https://npillmayer.github.io/media/plugins/featherIcons/feather-sprite.svg#home"/></svg> <span>Home</span></a></li><li><a class="tltp" href="https://npillmayer.github.io/typography-landing/" target="_self" aria-label="Typography"><svg class="fi fi-type" width="24px" height="24px" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><use href="https://npillmayer.github.io/media/plugins/featherIcons/feather-sprite.svg#type"/></svg> <span>Typography</span></a></li><li><a class="tltp" href="https://npillmayer.github.io/parsers-landing/" target="_self" aria-label="Parsers"><svg class="fi fi-code" width="24px" height="24px" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><use href="https://npillmayer.github.io/media/plugins/featherIcons/feather-sprite.svg#code"/></svg> <span>Parsers</span></a></li><li><a class="tltp" href="https://npillmayer.github.io/tags/" target="_self" aria-label="Topics"><svg class="fi fi-tag" width="24px" height="24px" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><use href="https://npillmayer.github.io/media/plugins/featherIcons/feather-sprite.svg#tag"/></svg> <span>Topics</span></a></li></ul></nav><a class="logo logo--atbottom" href="https://github.com/npillmayer" target="_blank" rel="noopener noreferrer"><img class="tltp" src="https://npillmayer.github.io/media/files//github-logo.png" alt="My GitHub Page" loading="lazy"></a></header></div></div><main class="main post"><article class="content"><figure class="content__featured-image content__featured-image--attop"><img src="https://npillmayer.github.io/media/posts/1/GoRGO-Logo-small.png" srcset="https://npillmayer.github.io/media/posts/1/responsive/GoRGO-Logo-small-xs.png 320w, https://npillmayer.github.io/media/posts/1/responsive/GoRGO-Logo-small-sm.png 480w, https://npillmayer.github.io/media/posts/1/responsive/GoRGO-Logo-small-md.png 768w, https://npillmayer.github.io/media/posts/1/responsive/GoRGO-Logo-small-xl.png 1024w" sizes="(min-width: 1460px) 938px, (min-width: 1200px) calc(75.83vw - 154px), (min-width: 1120px) 938px, (min-width: 900px) calc(55vw + 333px), 100vw" loading="eager" height="460" width="616" alt="GoRGO Logo" aria-describedby="image-caption"></figure><div class="content__meta content__meta--attop"><div class="content__meta--attop__inner"><div class="content__maintag"><svg width="20" height="20" aria-hidden="true" focusable="false"><use xlink:href="https://npillmayer.github.io/assets/svg/svg-map.svg#tag"/></svg> Published in <a href="https://npillmayer.github.io/tags/parsing/" class="metadata__maintag">Parsing</a></div></div></div><div class="main__inner"><div class="content__meta"><div class="content__date"><time datetime="2021-01-02T20:28">Jan 2, 2021</time></div></div><header class="content__header"><h1 class="content__title">Why GoRGO?</h1><p class="content__lead">What is GoRGO and how did it come to be</p></header><div class="content__entry"><p>Every software developer hates repetitive tasks. What’s the point of being a programmer if you can’t delegate your chores to a machine? And as a backend developer you are most likely open to the idea to employ some kind of domain specific language (DSL). That’s where a compiler generator may come into play. There is no shortage of them, ranging from good old <em>bison</em> to <em>ANTLR</em> and various Go variants like <em>gocc</em>. Why develop another one? Because GoRGO is a little different.</p><h3 id="what-is-it-about">What is it about?</h3><p>I have used many of the aforementioned tools extensively in my life, plus a handful of situations where I’ve written recursive descent parsers by hand. All these tools have their value and I appreciate the availability of compiler-compilers with a lot of horse power. But on the other hand, sometimes I want something more compact, a smart and lightweight tool to generate an interpreter for a custom language. And I want it in native Go, as this is what I currently use for Open Source. That’s what GoRGO strives to be.</p><h3 id="the-name">The Name</h3><p>The “RGO” in GoRGO stands for <strong>R</strong>ight-derivated <strong>G</strong>rammar <strong>O</strong>perations, which may sound all gibberish to you (and I wouldn’t blame you). But there’s a hint in this name: we will focus on LR-parsing, i.e., we will construct bottom-up parsers which produce right-derivations. That’s exactly what <em>yacc</em> et al do (unlike <em>ANTLR</em>, which produces LL-parsers), so no surprise there—or is it? In fact it should be, as DSL parsers these days are implemented with PEGs most of the time. But PEGs (parser expression grammars) are top-down, so why opt for bottom-up parsing?</p><div><div class="sidebox"><h5>Gorgosaurus</h5><p>Gorgo⋅saurus (<em>fierce lizard </em>) was not quite as big or famous as Tyrannosaurus Rex, but dangerous nevertheless. It lived some 75 million years ago in Northern America, <strong>eating anything</strong> it came across. We will meet its cousin T-Rex again when we'll talk about TeREx, a term rewriter.&nbsp;</p></div><p>PEG parsers have a number of disadvantages for the careless user—which includes myself. Although I love their simplicity, they lack a certain foolproofness which I expect for ad-hoc DSLs. Most ad-hoc grammars people write contain <em>ambiguous rules</em>, and PEGs hide ambiguity rather than resolving it. On the other hand, we do not want programmers to have to fix shift|reduce-conflicts and the like. The tool should just eat my grammar! Therefore we revert to LR-parsers, acknowledging the fact that we have to convince the parser to not be so tough on its users.</p><h3 id="no-code-generation">No Code Generation</h3><p>Parser generators (compiler compilers) usually generate source code. That’s often a good idea, as many of these tools can handle a multitude of host-languages. Moreover, Go has a mechanism for preprocessing and code-generation (<code>go-generate</code>) which is well suited for parser generators. However, for small DSLs I prefer to skip a code-generation step and rather create the parser in place and immediately run it.</p><p>Digesting the grammar is always the first step. This results in a bunch of <em>LR parse tables</em>. Instead of saving these tables as source code into a file, we keep them in memory and provide them to a parser. Table generation is quick for small languages and we usually can afford to go through this step once per program execution.</p><h3 id="ambiguous-grammars">Ambiguous Grammars</h3><p>Conventional parser generator do not handle ambiguous grammars well. Especially for ad-hoc DSLs, however, grammar ambiguity is quite common. Parser which can handle these kinds of grammars have been known for some time, but rarely gained popularity (<em>bison’s</em> GLR-feature is an exception to this rule and <em>ANTLR</em> mitigates many of these problems, too). GoRGO implementes two flavors of bottom-up parsers which are able to cope with ambiguty: Earley parsing and GLR-parsing.</p><p>During tests for various DSL tasks I came to love Earley-parsing. Sketching out a grammar, attaching it into an Earley parser and feeding it some sample input, all with a couple lines of code, is a satisfying experience. In theory Earley parsing can severly degrade in performance, but I have yet to come across such a case in practice. I will talk more on Earley-parsing in a different post.</p><p>GoRGO is an ongoing experiment. Stay tuned for some real-world application stories.</p></div><footer class="content__footer"><div class="content__last-updated">This article was updated on <time datetime="2026-01-23T10:44">Jan 23, 2026</time></div><div class="content__share"></div></footer></div></div></article></main><div class="right-bar"><div class="right-bar__inner"><div class="sidebar"><section class="box featured"><h3 class="box__title">Featured Posts</h3><ul class="featured__container"><li class="featured__item"><a href="https://npillmayer.github.io/posts/why-gorgo/" class="featured__image"><img src="https://npillmayer.github.io/media/posts/1/responsive/GoRGO-Logo-small-xs.png" loading="lazy" alt="GoRGO Logo" height="460" width="460"></a><div><a href="https://npillmayer.github.io/posts/why-gorgo/" class="featured__title">Why GoRGO?</a></div></li></ul></section><section class="box tags"><h3 class="box__title">Recommended Topics</h3><ul class="tags__list"><li class="tags__item"><a href="https://npillmayer.github.io/tags/graphics/" class="btn btn--gray">Graphics</a></li><li class="tags__item"><a href="https://npillmayer.github.io/tags/parsing/" class="btn btn--gray">Parsing</a></li><li class="tags__item"><a href="https://npillmayer.github.io/tags/typography/" class="btn btn--gray">Typography</a></li><li class="tags__item"><a href="https://npillmayer.github.io/tags/unicode/" class="btn btn--gray">Unicode</a></li></ul></section><div class="box copyright"><a href="https://www.pillmayer.com/norbert-pillmayer/" target="_blank" rel="noopener noreferrer">© Norbert Pillmayer</a></div></div></div></div></div><script defer="defer" src="https://npillmayer.github.io/assets/js/scripts.min.js?v=b2d91bcadbf5db401b76eb5bb3092eb7"></script><script>var images = document.querySelectorAll('img[loading]');
        for (var i = 0; i < images.length; i++) {
            if (images[i].complete) {
                images[i].classList.add('is-loaded');
            } else {
                images[i].addEventListener('load', function () {
                    this.classList.add('is-loaded');
                }, false);
            }
        }</script></body></html>