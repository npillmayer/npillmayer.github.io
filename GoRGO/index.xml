<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>A Parsing Toolbox in Go</title>
    <link>http://npillmayer.github.io/GoRGO/</link>
    <description>Recent content on A Parsing Toolbox in Go</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Norbert Pillmayer</copyright>
    <lastBuildDate>Thu, 03 Dec 2020 13:54:30 +0100</lastBuildDate>
    
        <atom:link href="http://npillmayer.github.io/GoRGO/index.xml" rel="self" type="application/rss+xml" />
    
    
    
        <item>
        <title>Why GoRGO?</title>
        <link>http://npillmayer.github.io/GoRGO/posts/why-gorgo/</link>
        <pubDate>Thu, 03 Dec 2020 13:54:30 +0100</pubDate>
        
        <guid>http://npillmayer.github.io/GoRGO/posts/why-gorgo/</guid>
        <description>A Parsing Toolbox in Go http://npillmayer.github.io/GoRGO/posts/why-gorgo/ -&lt;h1 id=&#34;what-is-it-about&#34;&gt;What is it about?&lt;/h1&gt;
&lt;p&gt;Every software developer I know hates repetitive tasks. What&amp;rsquo;s the point of being a programmer if
you can&amp;rsquo;t delegate your chores to a machine? And as a backend developer you are most likely open to
the idea to employ some kind of domain specific language (DSL).
That&amp;rsquo;s where a compiler generator may come into play. There is no shortage of them, ranging from good
old &lt;em&gt;bison&lt;/em&gt; to &lt;em&gt;ANTLR&lt;/em&gt; and various Go variants like &lt;em&gt;gocc&lt;/em&gt;. Why develop another one?&lt;/p&gt;
&lt;p&gt;I have used many of the aforementioned tools extensively in my life, plus a handful of situations where I&amp;rsquo;ve
written recursive descent parsers by hand. All these tools have their value and I appreciate the availability of
compiler-compilers with a lot of horse power. But on the other hand, sometimes I want something more compact,
a smart and lightweight tool to generate an interpreter for a custom language. And I want it in native Go,
as this is what I currently use for Open Source. That&amp;rsquo;s what GoRGO strives to be.&lt;/p&gt;
&lt;h2 id=&#34;the-name&#34;&gt;The Name&lt;/h2&gt;
&lt;p&gt;The &amp;ldquo;RGO&amp;rdquo; in GoRGO stands for &lt;strong&gt;R&lt;/strong&gt;ight-derivated &lt;strong&gt;G&lt;/strong&gt;rammar &lt;strong&gt;O&lt;/strong&gt;perations, which may sound all gibberish to you
(and I wouldn&amp;rsquo;t blame you). But there&amp;rsquo;s a hint in this name that we will focus on LR-parsing, i.e., we will
construct bottom-up parsers which produce right-derivations. That&amp;rsquo;s exactly what &lt;em&gt;yacc&lt;/em&gt; et al do (unlike
&lt;em&gt;ANTRL&lt;/em&gt;, which produces LL-parsers), so no surprise thereâ€”or is it? In fact it should be, as DSL parsers
these days are implemented with PEGs most of the time. But PEGs (parser expression grammars) are top-down,
so why clinge to LR-parsing?&lt;/p&gt;

&lt;div class=&#34;panel panel-default&#34; style=&#34;float:right; max-width:280px&#34;&gt;
  &lt;div class=&#34;panel-heading&#34;&gt;&lt;h5&gt;Gorgosaurus&lt;/h5&gt;&lt;/div&gt;
  &lt;p style=&#34;line-height:1.1rem;margin-top:4px&#34;&gt;
Gorgosaurus (&lt;em&gt;fierce lizard&lt;/em&gt;&amp;#x2009;)
was not quite as big or famous as Tyrannosaurus Rex, but dangerous nevertheless.
It lived some 75 million years ago in Northern America, &lt;b&gt;eating anything&lt;/b&gt; it came across.
We will meet its cousin T-Rex again when we&#39;ll talk about TeREx.
&lt;/p&gt;
&lt;/div&gt;


&lt;p&gt;PEG parsers have a number of disadvantages for the careless user. Although I love their simplicity,
they lack a certain foolproofness
which I expect for ad-hoc DSLs. Most ad-hoc grammars people write contain &lt;em&gt;ambiguous rules&lt;/em&gt;, and PEGs
hide ambiguity rather than resolving it. On the other hand, we do not want programmers to fix
shift|reduce-conflicts and the like. The tool should &lt;em&gt;just eat&lt;/em&gt; my grammar! Therefore we revert to
LR-parsers, acknowledging the fact that we have to convince the parser to not be so tough on its users.&lt;/p&gt;
&lt;p&gt;GoRGO follows a few design paradigm which in some aspects differ from your garden-variety parser
generator.&lt;/p&gt;
&lt;h2 id=&#34;no-code-generation&#34;&gt;No Code Generation&lt;/h2&gt;
&lt;p&gt;Parser generators (compiler compilers) usually generate source code. That&amp;rsquo;s often a good idea, as
many of these tools can handle a multitude of host languages. Moreover, Go has a mechanism for preprocessing and
code-generation (&lt;code&gt;go-generate&lt;/code&gt;) which is well suited for parser generators. However, for small
DSLs I prefer to skip a code-generation step and rather create the parser in code and immediately run it.&lt;/p&gt;
&lt;p&gt;Digesting the grammar always comes first, and results in a bunch of &lt;em&gt;LR parse tables&lt;/em&gt;. Instead of saving these
tables as source code into a file, we keep them in memory and provide them to a parser. Table generation is
quick for small languages and we can afford to go through this step once per program execution.&lt;/p&gt;
&lt;h2 id=&#34;ambiguous-grammars&#34;&gt;Ambiguous Grammars&lt;/h2&gt;
&lt;p&gt;Conventional parser generator do not handle ambiguous grammars well. Especially for ad-hoc DSL, however,
grammar ambiguity is quite common. Parser which can handle these kinds of grammars have been known for
some time, but rarely gained popularity (&lt;em&gt;bison&lt;/em&gt; is an exception to this rule and &lt;em&gt;ANTRL&lt;/em&gt; mitigates many
of these problems, too). GoRGO implementes two flavors of bottom-up parsers, which can cope with
ambiguty: Earley parsing and GLR-parsing.&lt;/p&gt;
&lt;p&gt;During tests for various DSL tasks I came to love Earley-parsing. Sketching out a grammar, attaching it into
an Earley parser and feeding it some sample input, all with a couple lines of code,
is a satisfying experience. In theory Earley parsing can
severly degrade in performance, but I have yet to come across such a case in practice.&lt;/p&gt;
&lt;p&gt;GoRGO is an ongoing experiment. Stay tuned for some real-world application stories.&lt;/p&gt;- http://npillmayer.github.io/GoRGO/posts/why-gorgo/ - Norbert Pillmayer</description>
        </item>
    
    
  </channel>
</rss> 